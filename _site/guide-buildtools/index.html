<p style="text-align:center;">
    Construct your prompt from the instructions below then use the E4S Guide Bot
</p>
<style>
/* E4S theme-adaptive pill button with white text */
.btn--e4s {
  background-color: var(--e4s-blue);
  color: #ffffff !important;
  border: none;
  border-radius: 9999px;
  padding: 0.6em 1.6em;
  font-weight: 600;
  display: inline-block;
  transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
  text-decoration: none;
}
.btn--e4s:hover,
.btn--e4s:focus {
  background-color: var(--e4s-blue-hover);
  color: #ffffff !important;
  text-decoration: none;
}
:root {
  --e4s-blue: #0092ca;
  --e4s-blue-hover: #006b99;
}
[data-theme="dark"] {
  --e4s-blue: #33b8f2;
  --e4s-blue-hover: #66ccff;
}
</style>

<p style="text-align:center;">
  <a href="https://chatgpt.com/g/g-69010fb294b0819195727cf1a7ccc792-software-ecosystem-for-science-guide" class="btn btn--e4s">Chat with the E4S Guide Bot</a>
</p>

<h2 id="introduction">Introduction</h2>

<p>E4S includes a variety of build tools that simplify the process of configuring, compiling, and installing scientific software across diverse high-performance computing (HPC) environments. Build tools are a critical part of the software lifecycle, ensuring reproducible builds, compatibility with system architectures, and integration with package managers such as Spack.</p>

<p>Selecting the right build tool depends on factors such as portability needs, dependency complexity, supported platforms, and project maturity. Some tools focus on package-level builds (like CMake or Autotools), while others manage complex dependency graphs (like Spack or EasyBuild). E4S supports and tests a wide range of build tools across architectures including x86, ARM, POWER, and GPUs from NVIDIA, AMD, and Intel.</p>

<blockquote>
  <p><strong>Example:</strong>
I am building a scientific simulation code that will run on both local workstations and leadership-class HPC systems using AMD and NVIDIA GPUs.<br />
I need reproducible builds that integrate with Spack and support cross-compilation for GPU targets.<br />
Ease of use and automated dependency management are important, but I also need fine control over compiler flags for performance tuning.<br />
My code uses CMake for configuration, but I want to explore whether another tool might simplify dependency management and multi-architecture builds.<br />
Please recommend a build tool or toolchain configuration based on these attributes:</p>
  <ul>
    <li>Portability: High</li>
    <li>Dependency Management: Automated</li>
    <li>Integration with Package Managers: Required</li>
    <li>Reproducibility: High</li>
    <li>Hardware Tuning: Required for GPU optimization</li>
    <li>Parallel Build Support: Yes</li>
    <li>Debugging Support: Helpful for research prototyping</li>
  </ul>
</blockquote>

<p>The tables below provide attributes that can help a newcomer or an automated assistant select an appropriate build tool for a given environment or development scenario.</p>

<hr />

<h2 id="broadly-meaningful-attributes">Broadly Meaningful Attributes</h2>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Portability</td>
      <td>The ability of the build tool to operate across multiple architectures and operating systems.</td>
    </tr>
    <tr>
      <td>Ease of Use</td>
      <td>How straightforward it is to configure, build, and install software with minimal manual intervention.</td>
    </tr>
    <tr>
      <td>Dependency Management</td>
      <td>How well the tool manages software dependencies and ensures version compatibility.</td>
    </tr>
    <tr>
      <td>Integration with Package Managers</td>
      <td>The degree to which the build tool integrates with higher-level systems such as Spack or system package managers.</td>
    </tr>
    <tr>
      <td>Reproducibility</td>
      <td>The ability to recreate the same build environment and outputs consistently.</td>
    </tr>
    <tr>
      <td>Build Customization</td>
      <td>The flexibility in specifying build options, compiler flags, and target architectures.</td>
    </tr>
    <tr>
      <td>Parallel Build Support</td>
      <td>The extent to which the tool supports multi-threaded or distributed builds.</td>
    </tr>
    <tr>
      <td>Documentation and Community</td>
      <td>Availability of documentation, tutorials, and an active community or ecosystem.</td>
    </tr>
    <tr>
      <td>Licensing and Openness</td>
      <td>Whether the tool is open source and compliant with E4Sâ€™s open-science principles.</td>
    </tr>
    <tr>
      <td>Interoperability</td>
      <td>Compatibility with multiple compilers (GNU, LLVM, Intel, Cray, etc.) and runtime environments.</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="situation-specific-attributes">Situation-Specific Attributes</h2>

<h3 id="for-portable-software-development">For Portable Software Development</h3>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Cross-Compilation Support</td>
      <td>Ability to build for different target architectures from a single development environment.</td>
    </tr>
    <tr>
      <td>Toolchain Integration</td>
      <td>Compatibility with major compiler toolchains (e.g., GCC, LLVM, oneAPI, ROCm).</td>
    </tr>
    <tr>
      <td>Environment Modules Support</td>
      <td>Ease of integration with environment modules used on HPC systems.</td>
    </tr>
    <tr>
      <td>Platform Autodetection</td>
      <td>Ability to detect available hardware and adjust build configuration automatically.</td>
    </tr>
  </tbody>
</table>

<h3 id="for-multi-package-or-ecosystem-builds">For Multi-Package or Ecosystem Builds</h3>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Dependency Graph Handling</td>
      <td>Ability to manage complex dependency trees automatically.</td>
    </tr>
    <tr>
      <td>Version Control Integration</td>
      <td>Support for Git, GitHub, or GitLab workflows in building and testing multiple packages.</td>
    </tr>
    <tr>
      <td>Continuous Integration Compatibility</td>
      <td>Integration with CI systems such as GitHub Actions, GitLab CI, or Frank CI.</td>
    </tr>
    <tr>
      <td>Binary Cache Management</td>
      <td>Ability to store and reuse build artifacts to reduce rebuild times.</td>
    </tr>
  </tbody>
</table>

<h3 id="for-performance-optimization-and-hardware-specific-builds">For Performance Optimization and Hardware-Specific Builds</h3>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Hardware Tuning</td>
      <td>Support for architecture-specific optimizations (e.g., vectorization, GPU acceleration).</td>
    </tr>
    <tr>
      <td>Compiler-Specific Optimization</td>
      <td>Ability to leverage vendor compilers for improved performance.</td>
    </tr>
    <tr>
      <td>Benchmark Integration</td>
      <td>Capability to build with or for performance benchmarking frameworks (e.g., HPCG, ReFrame).</td>
    </tr>
    <tr>
      <td>SDK Awareness</td>
      <td>Integration with vendor SDKs (e.g., CUDA, ROCm, oneAPI).</td>
    </tr>
  </tbody>
</table>

<h3 id="for-development-and-research-prototyping">For Development and Research Prototyping</h3>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Incremental Build Support</td>
      <td>Ability to rebuild only changed components during development.</td>
    </tr>
    <tr>
      <td>Debugging Support</td>
      <td>Integration with debuggers and profilers.</td>
    </tr>
    <tr>
      <td>Build Logging and Diagnostics</td>
      <td>Quality of output logs and error reporting to aid troubleshooting.</td>
    </tr>
    <tr>
      <td>Scriptability</td>
      <td>Ability to automate builds via Python or shell scripting interfaces.</td>
    </tr>
  </tbody>
</table>

<h3 id="for-large-scale-or-production-deployment">For Large-Scale or Production Deployment</h3>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Scalability</td>
      <td>Ability to handle large-scale builds on distributed systems.</td>
    </tr>
    <tr>
      <td>Security and Verification</td>
      <td>Availability of checksums, cryptographic signing, or provenance metadata.</td>
    </tr>
    <tr>
      <td>Policy Compliance</td>
      <td>Support for site-specific build policies and reproducibility requirements.</td>
    </tr>
    <tr>
      <td>Lifecycle Management</td>
      <td>Tools or hooks for maintaining, upgrading, and deprecating software builds.</td>
    </tr>
  </tbody>
</table>
