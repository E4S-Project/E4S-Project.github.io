<p>E4S provides a curated collection of open-source, high-performance scientific software packages, including a robust set of mathematical libraries covering linear algebra, eigensolvers, nonlinear systems, ODE/DAE integrators, optimization, stochastic methods and other advanced capabilities.</p>

<p>For newcomers, here’s a primer on how these math libraries fit into computational science workflows:</p>
<ul>
  <li>Mathematical libraries are the reusable building-blocks that provide capabilities such as solving large systems of algebraic equations, computing eigenvalues, integrating time-dependent differential equations, performing optimization, and handling stochastic or uncertainty-quantified models.</li>
  <li>In an HPC or scientific-simulation context, these libraries are designed for parallel execution (distributed / shared memory, MPI, accelerators such as GPUs) and are often “performance portable” across architectures. E4S emphasizes this cross-platform support (Intel, AMD, Arm, NVIDIA, etc.).</li>
  <li>From a user’s perspective, leveraging these libraries means you can build your application at a higher level (your physical model, discretisation, solver workflow) while relying on tested, optimized components for the “heavy lifting” of numerics.</li>
</ul>

<h2 id="the-value-of-using-optimized-libraries">The value of using optimized libraries</h2>
<p>Why invest effort in using these optimized, community-supported math libraries rather than writing one’s own routines or using naïve implementations? A few key reasons:</p>

<ol>
  <li>
    <p><strong>Performance and scalability</strong><br />
Optimized libraries exploit architecture-specific optimisations (cache hierarchies, vectorisation, multi-threading, GPU acceleration, efficient MPI communication). In large-scale simulations the solver cost often dominates — using a tuned library can reduce runtime significantly and make problems feasible.</p>

    <p>For example, high-performance linear algebra packages like PETSc or Trilinos provide scalable solvers and preconditioners that application developers would incur large effort to re-implement and tune.</p>
  </li>
  <li>
    <p><strong>Robustness and correctness</strong><br />
Mature libraries have been used, tested and debugged in many contexts (leading-edge HPC systems, real scientific applications, exascale projects). They include sophisticated features: adaptive error control, checkpoint/restart, sensitivity and adjoint support, GPU porting, etc. By using them you reduce your risk of subtle numerical bugs, memory leaks, performance bottlenecks, or poor parallel scaling.</p>
  </li>
  <li>
    <p><strong>Productivity and maintainability</strong><br />
Instead of investing time in re-writing numerical solvers, you focus on the domain model, discretisation, coupling, or scientific questions. When libraries evolve (new hardware, new algorithms, bug-fixes) you benefit via upstream updates. With E4S you get from-source builds, containers and pre-built binaries of these libraries, easing deployment and reproducibility.</p>
  </li>
  <li>
    <p><strong>Portability across architectures</strong><br />
Many optimized libraries within E4S are designed for performance portability: same high-level API but underlying backends support CPUs, GPUs, many-core accelerators, different memory hierarchies. This becomes critical when targeting leadership-class machines or pre-exascale/exascale systems. Applications that rely on hand‐rolled single‐threaded code may struggle to scale or migrate.</p>
  </li>
  <li>
    <p><strong>Ecosystem interoperability and community support</strong><br />
Using well-supported libraries links you to broader ecosystems (libraries for preconditioners, mesh tools, discretisation frameworks). The E4S stack intentionally fosters interoperability via packaging (Spack) and SDKs (e.g., the xSDK).</p>
  </li>
</ol>

<p>In summary: for scientifically credible, performant, maintainable and portable computation, leveraging optimized math libraries is highly recommended.</p>

<hr />

<h1 id="overview-of-main-math-library-categories-in-e4s">Overview of Main Math Library Categories in E4S</h1>
<p>Below are summary tables categorised by solver type. These are representative of key libraries in release 25.06 (as of June 2025) and reflect what you might expect to find in the “Math libraries” family of E4S. They are not exhaustive but provide a useful map for a newcomer.</p>

<h3 id="meshing-discretization-and-adaptive-mesh-refinement"><strong>Meshing, Discretization, and Adaptive Mesh Refinement</strong></h3>

<table>
  <thead>
    <tr>
      <th>Library</th>
      <th>Key Capabilities</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>MFEM</strong></td>
      <td>Finite element discretization, adaptive mesh refinement (AMR), GPU support</td>
      <td>Widely used for multiphysics codes; part of xSDK and E4S</td>
    </tr>
    <tr>
      <td><strong>libMesh</strong></td>
      <td>Finite element framework supporting adaptive mesh refinement and parallel I/O</td>
      <td>C++ based; good for large-scale multiphysics applications</td>
    </tr>
    <tr>
      <td><strong>PUMI (Parallel Unstructured Mesh Infrastructure)</strong></td>
      <td>Mesh generation, partitioning, and adaptation for unstructured meshes</td>
      <td>Integrates with Albany and other Trilinos-based codes</td>
    </tr>
    <tr>
      <td><strong>Omega_h</strong></td>
      <td>Parallel mesh adaptation and redistribution on GPUs</td>
      <td>Lightweight, performant C++/Kokkos design</td>
    </tr>
    <tr>
      <td><strong>MOAB</strong></td>
      <td>Mesh-Oriented data management and topology library</td>
      <td>Foundation for geometry-mesh coupling and I/O</td>
    </tr>
    <tr>
      <td><strong>AMReX</strong></td>
      <td>Structured mesh AMR framework for block-structured PDE solvers</td>
      <td>Core to several DOE exascale applications</td>
    </tr>
    <tr>
      <td><strong>ParMETIS / Zoltan</strong></td>
      <td>Graph partitioning and dynamic load balancing</td>
      <td>Supports scalable adaptive refinement workflows</td>
    </tr>
  </tbody>
</table>

<h3 id="linear-solvers">Linear Solvers</h3>

<table>
  <thead>
    <tr>
      <th>Library</th>
      <th>Key capabilities</th>
      <th>Notes / remarks</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>PETSc (Portable Extensible Toolkit for Scientific Computation)</td>
      <td>Sparse/dense linear systems, iterative and direct solvers, preconditioning, GPU support</td>
      <td>Widely used in PDE-based applications; part of E4S.</td>
    </tr>
    <tr>
      <td>Trilinos (via sub-packages e.g., Tpetra, Belos, Ifpack, MueLu)</td>
      <td>Distributed linear algebra, preconditioners, block solvers, multigrid support</td>
      <td>Broad toolkit; integrates into many domain codes.</td>
    </tr>
    <tr>
      <td>SLATE (Software for Linear Algebra Targeting Exascale)</td>
      <td>Dense linear algebra (e.g., factorisations, BLAS/LAPACK style) for many-core/accelerators</td>
      <td>Focused on exascale dense problems.</td>
    </tr>
    <tr>
      <td>Ginkgo</td>
      <td>High-performance linear algebra on many-core and accelerator processors</td>
      <td>Good for GPU sparse/dense linear algebra.</td>
    </tr>
  </tbody>
</table>

<h3 id="eigensolvers">Eigensolvers</h3>

<table>
  <thead>
    <tr>
      <th>Library</th>
      <th>Key capabilities</th>
      <th>Notes / remarks</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Anasazi / Belos (in Trilinos)</td>
      <td>Krylov methods (Arnoldi, Lanczos) for eigenvalue problems</td>
      <td>Suitable for large sparse eigen-systems within Trilinos.</td>
    </tr>
    <tr>
      <td>SLEPc (Scalable Library for Eigenvalue Problem Computations)</td>
      <td>Scalable eigenvalue solvers, time-dependent eigenvalue problems</td>
      <td>Often used in research codes; supports PETSc integration.</td>
    </tr>
    <tr>
      <td>Spectra, ARPACK/ARPACK-NG</td>
      <td>Sparse eigenvalue solvers (smaller scale)</td>
      <td>Useful fallback for moderate-size eigenproblems.</td>
    </tr>
  </tbody>
</table>

<h3 id="nonlinear-solvers">Nonlinear Solvers</h3>

<table>
  <thead>
    <tr>
      <th>Library</th>
      <th>Key capabilities</th>
      <th>Notes / remarks</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>PETSc SNES (Scalable Nonlinear Equations Solvers)</td>
      <td>Newton and quasi-Newton methods, line-search/trust-region, coupling to KSP for linear sub-solve</td>
      <td>Well integrated in PETSc’s workflow.</td>
    </tr>
    <tr>
      <td>Trilinos NOX</td>
      <td>Nonlinear solver toolkit (Newton–Krylov)</td>
      <td>Similar role in the Trilinos ecosystem.</td>
    </tr>
    <tr>
      <td>TAO (Toolkit for Advanced Optimization)</td>
      <td>Although more for optimisation, often handles nonlinear systems too (via KKT systems)</td>
      <td>Included in E4S math libraries.</td>
    </tr>
  </tbody>
</table>

<h3 id="daeode-solvers">DAE/ODE Solvers</h3>

<table>
  <thead>
    <tr>
      <th>Library</th>
      <th>Key capabilities</th>
      <th>Notes / remarks</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>PETSc/TS (time-stepping)</td>
      <td>ODE and DAE solver suite (explicit, implicit, IMEX), sensitivity/adjoint support</td>
      <td>Scalable time integration library.</td>
    </tr>
    <tr>
      <td>SUNDIALS (Suite of Nonlinear and Differential/Algebraic Equation Solvers)</td>
      <td>CVODE, IDA/IDA00 etc: stiff/non-stiff ODE/DAE, sensitivity, parallel support</td>
      <td>Often used in multiphysics/chemistry codes.</td>
    </tr>
    <tr>
      <td>ODEPACK, DASSL</td>
      <td>Classic integrator libraries (smaller scale)</td>
      <td>Good for legacy codes or small-scale problems.</td>
    </tr>
  </tbody>
</table>

<h3 id="mathematical-optimization-solvers">Mathematical Optimization Solvers</h3>

<table>
  <thead>
    <tr>
      <th>Library</th>
      <th>Key capabilities</th>
      <th>Notes / remarks</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TAO (Toolkit for Advanced Optimization)</td>
      <td>Large-scale nonlinear optimisation (unconstrained, bound-constrained, general constraints), adjoint support</td>
      <td>Integrated with PETSc solvers.</td>
    </tr>
    <tr>
      <td>Ipopt (Interior-point Optimisation)</td>
      <td>Nonlinear programming (large-scale)</td>
      <td>Widely used in engineering/operations research applications.</td>
    </tr>
    <tr>
      <td>Gurobi / CPLEX (when available)</td>
      <td>Commercial solvers for integer and continuous optimisation</td>
      <td>Sometimes wrapped or interfaced in HPC settings; check licence.</td>
    </tr>
  </tbody>
</table>

<h3 id="stochastic-and-other-advanced-capabilities">Stochastic and Other Advanced Capabilities</h3>

<table>
  <thead>
    <tr>
      <th>Library</th>
      <th>Key capabilities</th>
      <th>Notes / remarks</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>libEnsemble</td>
      <td>Ensemble‐based computing, dynamic task scheduling for uncertainty quantification, optimisation, machine learning workflows</td>
      <td>Enables high‐throughput simulations under UQ or optimisation loops.</td>
    </tr>
    <tr>
      <td>UQTK (Uncertainty Quantification Toolkit)</td>
      <td>Polynomial chaos, stochastic Galerkin, UQ workflows</td>
      <td>Useful when embedding stochastic modelling in HPC simulation.</td>
    </tr>
    <tr>
      <td>MOAB, Tasmanian, SNES stochastic modules</td>
      <td>Mesh management, sparse grids, stochastic solvers</td>
      <td>Advanced use cases often in multiphysics + UQ frameworks.</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="getting-started-how-to-pick-and-use-a-library-in-e4s">Getting Started: How to Pick and Use a Library in E4S</h2>

<p>Here are recommended steps for a newcomer:</p>

<ol>
  <li>
    <p><strong>Clarify your problem type</strong> – Are you solving large sparse linear systems (e.g., from discretised PDEs)? Do you need eigenvalues? Are you integrating time-dependent ODEs/DAEs? Is the core problem an optimization? Is stochastic/UQ involved? The category helps determine the solver family.</p>
  </li>
  <li>
    <p><strong>Check interoperability and dependencies</strong> – Ensure the library you pick is included and supported in E4S 25.06, and works with your platform (CPU type, GPU type, MPI version). E4S provides containers and build recipes for many architectures.</p>
  </li>
  <li>
    <p><strong>Start with a simple example</strong> – Each library typically provides tutorial codes (e.g., PETSc tutorials, SUNDIALS examples, TAO examples). Run a small problem to verify your build and environment.</p>
  </li>
  <li>
    <p><strong>Scale up and tune</strong> – Once the example works, apply it to your real problem. Pay attention to solver settings (tolerances, preconditioners, GPU offload flags). Optimized libraries often expose knobs to adjust performance (block size, reuse of factorisation, asynchronous communication).</p>
  </li>
  <li>
    <p><strong>Leverage upstream support and community</strong> – Because you’re using a mature library, you can ask community forums, look at mailing lists, and refer to documentation for advanced features (adjoint sensitivities, multi‐physics coupling, hybrid CPU/GPU execution).</p>
  </li>
  <li>
    <p><strong>Maintain reproducibility and portability</strong> – Because E4S provides pre-built binaries, containers (Docker, Singularity) and Spack recipes, you can capture your software stack (version, build options) for future replication or sharing with collaborators.</p>
  </li>
</ol>

<hr />

<h2 id="conclusion">Conclusion</h2>
<p>The math libraries supported in E4S offer a powerful foundation for high-performance scientific computing. By leveraging these optimized, community-supported libraries you gain performance, reliability, portability and productivity. As you embark on your project, identify the solver domain(s) you need, select the appropriate library from the tables above, run examples, and scale your application through the E4S-supported stack.</p>
